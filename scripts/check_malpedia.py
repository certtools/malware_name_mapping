#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2018-2019 nic.at GmbH
#
# SPDX-License-Identifier: CC0-1.0

# -*- coding: utf-8 -*-
"""
Iterates over all malpedia entries and checks if there is an existing rule for
all given alternative names.
"""
import argparse
import json
import os
import re
import sys

import requests

from common import load_mapping


def get_malpedia_names_online(username, password):
    malpedia_names = {}
    auth = (username, password)
    families_req = requests.get('https://malpedia.caad.fkie.fraunhofer.de/api/list/families', auth=auth)
    families_req.raise_for_status()  # missing login
    for family in families_req.json():
        if not family.startswith('win') or "unidentified" in family:
            continue
        malpedia_names[family] = [family[4:]]
        malpedia_names[family].extend(requests.get('https://malpedia.caad.fkie.fraunhofer.de/api/get/family/%s' % family, auth=auth).json()['alt_names'])
    return malpedia_names


def get_malpedia_names_offline(path):
    malpedia_names = {}
    if not os.path.isdir(path):
        sys.exit('{} is not a directory'.format(path))
    for family in os.listdir(path):
        if not family.startswith('win') or "unidentified" in family:
            continue
        malpedia_names[family] = [family[4:]]
        family_meta = {}
        with open(os.sep.join([path, family, family + '.json'])) as f_json:
            family_meta = json.load(f_json)
        malpedia_names[family].extend(family_meta['alt_names'])
    return malpedia_names


def check_mapping_regexes(regexes, malpedia_names):
    for family, names in malpedia_names.items():
        unmatched_names = []
        matching_regexes = []
        for name in names:
            for rule in regexes:
                if re.fullmatch(rule, name, re.IGNORECASE):
                    matching_regexes.append(rule)
                    break
            else:
                unmatched_names.append(name)
        if matching_regexes:
            print("Found at least one matching rule for malpedia family {}".format(family))
            print("    malpedia names: {}".format(names))
            print("    rules:          {}".format(list(set(matching_regexes))))
        if unmatched_names:
            print("No mapping for names '{}' of malpedia entry {}.".format("', '".join(unmatched_names), family))


def generate_mappings(regexes, malpedia_names, existing=False, new=False):
    all_families = {regex[1] for regex in regexes}

    for family, names in malpedia_names.items():
        familyname = family.split('.')[1]
        if familyname in all_families and not existing:
            continue
        unmatched_names = set()
        matching_regexes = []
        for name in names:
            for rule in regexes:
                if re.fullmatch(rule, name, re.IGNORECASE):
                    matching_regexes.append(rule)
                    break
            else:
                unmatched_names.add(name.lower().replace('.', r'\.').replace('_', '[ _-]?'))
        if existing and unmatched_names:
            print("Missing match for {} to family {}/{}".format(unmatched_names, family, familyname))
        if new and unmatched_names:
            if len(unmatched_names) > 1:
                print("\"^({})$\",{},malpedia".format("|".join(unmatched_names), familyname))
            else:
                print("\"^{}$\",{},malpedia".format(unmatched_names.pop(), familyname))


def main():
    parser = argparse.ArgumentParser(prog='check_malpedia', description='Checks if malpedia lists malware names which this mapping does not support.')
    parser.add_argument('-o', '--online', action='store_true', help='Check online against the Malpedia REST-API.')
    parser.add_argument('-u', '--username', type=str, default="", help='Malpedia Username (for online mode).')
    parser.add_argument('-p', '--password', type=str, default="", help='Malpedia Password (for online mode).')
    parser.add_argument('-m', '--malpedia_root', type=str, default="", help='Check offline against the Malpedia repository.')
    parser.add_argument('-ge', '--generate-existing', action='store_true', help='Generate missing existing mappings.')
    parser.add_argument('-gn', '--generate-new', action='store_true', help='Generate missing new mappings.')
    args = parser.parse_args()

    malpedia_names = {}
    if args.malpedia_root:
        malpedia_names = get_malpedia_names_offline(args.malpedia_root)
    elif args.online and args.username and args.password:
        malpedia_names = get_malpedia_names_online(args.username, args.password)
    else:
        parser.print_help()

    mapping = {line[0] for line in load_mapping()}
    if args.generate_new or args.generate_existing:
        generate_mappings(mapping, malpedia_names,
                          existing=args.generate_existing,
                          new=args.generate_new)
    else:
        check_mapping_regexes(mapping, malpedia_names)


if __name__ == "__main__":
    sys.exit(main())
